#+title: literate programming in org-mode with haskell

* enabling

* Haskell's org-babel support is rough 

* It would be great to have better support for dependencies

** allowing for something like this for cabal projects
#+begin_src haskell :deps-from ~/code/my-cool-cabal-based-haskell-project
  functionFromMyProj
#+end_src

** or my preference [[file:20210401185355-nix_powered_org_babel_blocks.org][nix powered org babel blocks]]


* here are some problems

** first problem, simple lists with mixed types don't work
*** if we get some output in the form of a list with mixed types in bash and call it =list-from-bash=

#+name: list-from-bash
#+begin_src sh
echo "1 some-text"
echo "2 some-text"
echo "3 some-text"
#+end_src

#+RESULTS: list-from-bash
| 1 | some-text |
| 2 | some-text |
| 3 | some-text |

*** these don't work in =sh -> haskell=

#+name: failing-haskell-example
#+begin_src haskell :var list=list-from-bash
print list
#+end_src

#+RESULTS: failing-haskell-example
| 1 | some-text |
| 2 | some-text |
| 3 | some-text |


Then if you look in the =*haskell*= ghci buffer that runs this code it becomes apparent why:

#+begin_example
Prelude> let list = [[1, "some-text"], [2, "some-text"], [3, "some-text"]]
print list
"org-babel-haskell-eoe"

<interactive>:23:14: error:
    • No instance for (Num [Char]) arising from the literal ‘1’
    • In the expression: 1
      In the expression: [1, "some-text"]
      In the expression:
        [[1, "some-text"], [2, "some-text"], [3, "some-text"]]
Prelude> [[1],[2],[3]]
Prelude> "org-babel-haskell-eoe"
#+end_example

*** how it should work: =sh -> elisp=

#+begin_src emacs-lisp :var list=list-from-bash :results list
  (mapcar
   (lambda (x) (format "%s: %s" (car x) (cadr x)))
   list)
#+end_src

#+RESULTS:
- 1: some-text
- 2: some-text
- 3: some-text

** solution: use lists of tuples instead of lists of lists 

*** solution (still hacky, breaks tuples of tuples maybe?)

**** make generate tuples of tuples

#+begin_src emacs-lisp
(defun org-babel-haskell-var-to-haskell (var)
  "Convert an elisp value VAR into a haskell variable.
The elisp VAR is converted to a string of haskell source code
specifying a variable of the same value."
  (if (listp var)
      (concat "(" (mapconcat #'org-babel-haskell-var-to-haskell var ", ") ")")
    (format "%S" var)))
#+end_src


**** make variable assignments of tuples of tuples replace outermost with braces

#+RESULTS:
: org-babel-haskell-var-to-haskell

#+begin_src emacs-lisp
(defun replace-outer-parens-with-braces-if-nested (str)
 (replace-regexp-in-string "))$" ")]" (replace-regexp-in-string "^((" "[(" str)) 
)
#+end_src

#+RESULTS:
: replace-outer-parens-with-braces-if-nested


#+begin_src emacs-lisp
  (defun org-babel-variable-assignments:haskell (params)
    "Return list of haskell statements assigning the block's variables."
    (mapcar (lambda (pair)
              (format "let %s = %s"
                      (car pair)
                      (replace-outer-parens-with-braces-if-nested (org-babel-haskell-var-to-haskell (cdr pair)))))
            (org-babel--get-vars params)))
#+end_src

#+RESULTS:
: org-babel-variable-assignments:haskell


**** test it again


#+begin_src haskell :var list=list-from-bash
map (\(n,s) -> show n <> ":" <> s) list
#+end_src

#+RESULTS:
| 1:some-text | 2:some-text | 3:some-text |


**** done!

*** work

**** I think the piece responsible for this is [[file:/nix/store/6my833s031f57s0wnksdxhasx4ga88z4-emacs-packages-deps/share/emacs/site-lisp/elpa/org-20210315/ob-haskell.el::defun org-babel-interpret-haskell (body params][org-babel-interpret-haskell]] 

**** this can be verified by calling trace-function on it like so
#+begin_src emacs-lisp
(trace-function-foreground 'org-babel-interpret-haskell)
#+end_src

**** then it's results look like
#+begin_example
(org-babel-interpret-haskell "print list" ((:var list (1 "some-text") (2 "some-text") (3 "some-text")) (:colname-names) (:rowname-names) (:result-params "replace") (:result-type . value) (:results . "replace") (:exports . "code") (:session . "none") (:cache . "no") (:noweb . "no") (:hlines . "no") (:tangle . "no") (:padlines . "no")))
#+end_example

**** we can call that directly actually

#+begin_src emacs-lisp :results verbatim
(org-babel-interpret-haskell "print list" '((:var list (1 "some-text") (2 "some-text") (3 "some-text")) (:colname-names) (:rowname-names) (:result-params "replace") (:result-type . value) (:results . "replace") (:exports . "code") (:session . "none") (:cache . "no") (:noweb . "no") (:hlines . "no") (:tangle . "no") (:padlines . "no")))
#+end_src

#+RESULTS:
: ((1) (2) (3))

**** we'd like the results to be
#+begin_example
: ((1) (2) (3))
#+end_example

**** Ah, this is all coming back to me

**** this logic is in [[file:/nix/store/6my833s031f57s0wnksdxhasx4ga88z4-emacs-packages-deps/share/emacs/site-lisp/elpa/org-20210315/ob-haskell.el::defun org-babel-haskell-var-to-haskell (var][org-babel-haskell-var-to-haskell]]
#+name: test-org-babel-haskell-var-to-haskell
#+begin_src emacs-lisp
(org-babel-haskell-var-to-haskell '((1 "some-text") (2 "some-text") (3 "some-text")))
#+end_src

#+RESULTS:
: [[1, "some-text"], [2, "some-text"], [3, "some-text"]]

**** it's very naieve as you can see and just makes lists of lists

**** let's make it smarter and friendlier to haskell using tuples

***** try 1

#+begin_src emacs-lisp
(defun org-babel-haskell-var-to-haskell (var)
  "Convert an elisp value VAR into a haskell variable.
The elisp VAR is converted to a string of haskell source code
specifying a variable of the same value."
  (if (listp var)
      (concat "(" (mapconcat #'org-babel-haskell-var-to-haskell var ", ") ")")
    (format "%S" var)))
#+end_src

#+RESULTS:
: org-babel-haskell-var-to-haskell

#+call: test-org-babel-haskell-var-to-haskell()

#+RESULTS:
: ((1, "some-text"), (2, "some-text"), (3, "some-text"))

Now let's try with our haskell example again

#+call: failing-haskell-example()

#+RESULTS:
| 1 | some-text |
| 2 | some-text |
| 3 | some-text |

Well... lookie there... that was pretty simple.

I know there is a limitation of this as well but can't remember.

Actually I think the limitation is that everything is now a string and Haskell isn't so friendly to that. So you either need to call fromString on all of these values or some type of general conversion to get them into types.

One way of doing this would be something I need to add to [[file:20210329205123-cool_project_idea.org][cool project idea]]: [[file:20210401231517-integrating_frames_and_type_detection_with_org_babel_s_haskell_integration.org][integrating frames and type detection with org babel's haskell integration]]


**** +there it is, we made lists from shell blocks work with haskell blocks+

The full original example:


#+name: list-from-bash
#+begin_src sh
echo "1 some-text"
echo "2 some-text"
echo "3 some-text"
#+end_src

#+RESULTS: list-from-bash
| 1 | some-text |
| 2 | some-text |
| 3 | some-text |

#+begin_src haskell :var list=list-from-bash
print list
#+end_src

#+RESULTS:
| 1 | some-text |
| 2 | some-text |
| 3 | some-text |

#+begin_src haskell :var list=list-from-bash
map (\(n,s) -> show n <> ":" <> s) list
#+end_src

#+RESULTS:
: <interactive>:72:36-39: error:
:     • Couldn't match expected type ‘[(a0, [Char])]’
:                   with actual type ‘((a10, [Char]), (a20, [Char]), (a30, [Char]))’
:     • In the second argument of ‘map’, namely ‘list’
:       In the expression: map (\ (n, s) -> show n <> ":" <> s) list
:       In an equation for ‘it’:
:           it = map (\ (n, s) -> show n <> ":" <> s) list


**** We need the outer items to be a list!

***** try 2, make it happen the hacky way

Set back the org-babel-haskell-var-to-haskell function to only make tuples of tuples:

#+begin_src emacs-lisp
  (defun org-babel-haskell-var-to-haskell (var)
  "Convert an elisp value VAR into a haskell variable.
The elisp VAR is converted to a string of haskell source code
specifying a variable of the same value."
  (if (listp var)
      (concat "(" (mapconcat #'org-babel-haskell-var-to-haskell var ", ") ")")
    (format "%S" var)))
#+end_src

#+RESULTS:
: org-babel-haskell-var-to-haskell

then we can do the hacky thing and replace the outer-most parens with braces... voila! a list of tuples!

#+begin_src emacs-lisp
(defun replace-outer-parens-with-braces (str)
 (replace-regexp-in-string ")$" "]" (replace-regexp-in-string "^(" "[" str)) 
)
#+end_src

#+begin_src emacs-lisp
(replace-outer-parens-with-braces "((1,\"two\"))")
#+end_src

#+RESULTS:
: [(1,"two")]


#+begin_src emacs-lisp
  (defun org-babel-variable-assignments:haskell (params)
    "Return list of haskell statements assigning the block's variables."
    (mapcar (lambda (pair)
              (format "let %s = %s"
                      (car pair)
                      (replace-outer-parens-with-braces (org-babel-haskell-var-to-haskell (cdr pair)))))
            (org-babel--get-vars params)))
#+end_src


#+call: test-org-babel-haskell-var-to-haskell()

#+RESULTS:
: ((1, "some-text"), (2, "some-text"), (3, "some-text"))


Now let's try with our haskell example again

#+call: failing-haskell-example()

#+RESULTS:
| 1 | some-text |
| 2 | some-text |
| 3 | some-text |

We can't see a difference here... but if we look in the =*haskell*= buffer we see:

#+begin_example
"org-babel-haskell-eoe"
Prelude> [(1,"some-text"),(2,"some-text"),(3,"some-text")]
Prelude> "org-babel-haskell-eoe"
#+end_example

And if we try our original test:

#+begin_src haskell :var list=list-from-bash
map (\(n,s) -> show n <> ":" <> s) list
#+end_src

#+RESULTS:
| 1:some-text | 2:some-text | 3:some-text |

We are now feature pair with elisp for this case.


** multi-line doesn't work by default

*** this code that should be perfectly fine 

#+begin_src haskell
data User = User { id :: Int, name :: String }

greetUser :: User -> IO ()
greetUser u = putStrLn (name u)

printUser :: User -> IO ()
printUser = print
#+end_src

*** gives error
#+begin_example
Prelude> "org-babel-haskell-eoe"
Prelude> data User = User { id :: Int, name :: String }

greetUser :: User -> IO ()
greetUser u = putStrLn (name u)

printUser :: User -> IO ()
printUser = print
"org-babel-haskell-eoe"
Prelude> Prelude> 
<interactive>:7:1-9: error:
    Variable not in scope: greetUser :: User -> IO ()
Prelude> Prelude> Prelude> 
<interactive>:10:1-9: error:
    Variable not in scope: printUser :: User -> IO ()
Prelude> Prelude> "org-babel-haskell-eoe"
#+end_example


*** you can workaround with

** vars are strings in babel... always... Haskell doesn't like that

*** [[*(blocked by stringly typed vars in babel) Though compatibility could also be kept if we used vars like][(blocked by stringly typed vars in babel) Though compatibility could also be kept if we used vars like]]

* Taking ob-haskell to the next level

** explanation

*** You have the following
  :PROPERTIES:
  :header-args: :session user-example-next-level
  :END:

#+name: 55Uuz5hb24zxrNzgp3Yi5b
#+begin_src haskell
:{
data User = User { id :: Int, name :: String } deriving Show

greetUser :: User -> IO ()
greetUser u = putStrLn $ "hello " ++ name u ++ "!"

printUser :: User -> IO ()
printUser = print
:}
#+end_src

#+RESULTS: 55Uuz5hb24zxrNzgp3Yi5b


*** Let's say you create a =User= like so

#+name: 3p6nNjy4a8RoNyxq8o4eKT
#+begin_src haskell
User 0 "Hercules"
#+end_src

#+RESULTS: 3p6nNjy4a8RoNyxq8o4eKT
: User {id = 0, name = "Hercules"}


*** What if that result block was special? 

*** special as in the sense of context-sensitive actions available?

*** What if you landed on that context-sensitive result by default after executing?

*** You then do =SPC c a= and are presented with a selectrum list like

#+begin_example
greetUser :: User -> IO
printUser :: User -> IO
#+end_example


*** Upon selecting, say =greetUser= it creates a newline under result and creates this code block

#+begin_src haskell :noweb yes
greetUser (<<3p6nNjy4a8RoNyxq8o4eKT>>)
#+end_src

#+RESULTS:
: hello Hercules!


*** ~NOTE~: the parens are necessary otherwise invalid haskell is created

#+begin_example
Prelude> "org-babel-haskell-eoe"
Prelude> greetUser User 0 "Hercules"
"org-babel-haskell-eoe"

<interactive>:37:1-27: error:
    • Couldn't match expected type ‘t0 -> [Char] -> t’
                  with actual type ‘IO ()’
    • The function ‘greetUser’ is applied to three arguments,
      but its type ‘User -> IO ()’ has only one
      In the expression: greetUser User 0 "Hercules"
      In an equation for ‘it’: it = greetUser User 0 "Hercules"
    • Relevant bindings include it :: t (bound at <interactive>:37:1)

<interactive>:37:11-14: error:
    • Couldn't match expected type ‘User’
                  with actual type ‘Int -> String -> User’
    • Probable cause: ‘User’ is applied to too few arguments
      In the first argument of ‘greetUser’, namely ‘User’
      In the expression: greetUser User 0 "Hercules"
      In an equation for ‘it’: it = greetUser User 0 "Hercules"
#+end_example


*** Or... if you want to keep better compatibility with lsp-org and haskell-language-server you'd pull out the noweb value directly like

#+begin_src haskell
greetUser (User {id = 0, name = "Hercules"})
#+end_src

#+RESULTS:
: hello Hercules!


*** (blocked by stringly typed vars in babel) Though compatibility could also be kept if we used vars like

#+begin_src haskell :var oNyxq=3p6nNjy4a8RoNyxq8o4eKT
greetUser (oNyxq)
#+end_src

#+RESULTS:
: <interactive>:60:12-16: error:
:     • Couldn't match expected type ‘User’ with actual type ‘[Char]’
:     • In the first argument of ‘greetUser’, namely ‘(oNyxq)’
:       In the expression: greetUser (oNyxq)
:       In an equation for ‘it’: it = greetUser (oNyxq)


*** After unblocking above, I think it provides the most synergy (heh)

*** But, for the time being that means [[*Or... if you want to keep better compatibility with lsp-org and haskell-language-server you'd pull out the noweb value directly like][direct inlining]] would be best

** TODO make completion function that uses entire result of source block as input

*** it might also be nice if this works within source blocks too

*** I think this will mostly be [[file:20210402205533-how_to_use_completing_read.org][how to use completing-read]]

** TODO optional? figure out how to make button for org babel haskell results

*** TODO [[file:20210402202533-making_custom_buttons_in_hyperbole.org][making custom buttons in hyperbole]]

*** TODO make a custom button for org babel results

